// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'address_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AddressType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() province,
    required TResult Function() district,
    required TResult Function() ward,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AddressProvinceType value) province,
    required TResult Function(_AddressDistrictType value) district,
    required TResult Function(_AddressWardType value) ward,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressTypeCopyWith<$Res> {
  factory $AddressTypeCopyWith(
          AddressType value, $Res Function(AddressType) then) =
      _$AddressTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddressTypeCopyWithImpl<$Res> implements $AddressTypeCopyWith<$Res> {
  _$AddressTypeCopyWithImpl(this._value, this._then);

  final AddressType _value;
  // ignore: unused_field
  final $Res Function(AddressType) _then;
}

/// @nodoc
abstract class _$$_AddressProvinceTypeCopyWith<$Res> {
  factory _$$_AddressProvinceTypeCopyWith(_$_AddressProvinceType value,
          $Res Function(_$_AddressProvinceType) then) =
      __$$_AddressProvinceTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AddressProvinceTypeCopyWithImpl<$Res>
    extends _$AddressTypeCopyWithImpl<$Res>
    implements _$$_AddressProvinceTypeCopyWith<$Res> {
  __$$_AddressProvinceTypeCopyWithImpl(_$_AddressProvinceType _value,
      $Res Function(_$_AddressProvinceType) _then)
      : super(_value, (v) => _then(v as _$_AddressProvinceType));

  @override
  _$_AddressProvinceType get _value => super._value as _$_AddressProvinceType;
}

/// @nodoc

class _$_AddressProvinceType implements _AddressProvinceType {
  _$_AddressProvinceType();

  @override
  String toString() {
    return 'AddressType.province()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AddressProvinceType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() province,
    required TResult Function() district,
    required TResult Function() ward,
  }) {
    return province();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
  }) {
    return province?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
    required TResult orElse(),
  }) {
    if (province != null) {
      return province();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AddressProvinceType value) province,
    required TResult Function(_AddressDistrictType value) district,
    required TResult Function(_AddressWardType value) ward,
  }) {
    return province(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
  }) {
    return province?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
    required TResult orElse(),
  }) {
    if (province != null) {
      return province(this);
    }
    return orElse();
  }
}

abstract class _AddressProvinceType implements AddressType {
  factory _AddressProvinceType() = _$_AddressProvinceType;
}

/// @nodoc
abstract class _$$_AddressDistrictTypeCopyWith<$Res> {
  factory _$$_AddressDistrictTypeCopyWith(_$_AddressDistrictType value,
          $Res Function(_$_AddressDistrictType) then) =
      __$$_AddressDistrictTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AddressDistrictTypeCopyWithImpl<$Res>
    extends _$AddressTypeCopyWithImpl<$Res>
    implements _$$_AddressDistrictTypeCopyWith<$Res> {
  __$$_AddressDistrictTypeCopyWithImpl(_$_AddressDistrictType _value,
      $Res Function(_$_AddressDistrictType) _then)
      : super(_value, (v) => _then(v as _$_AddressDistrictType));

  @override
  _$_AddressDistrictType get _value => super._value as _$_AddressDistrictType;
}

/// @nodoc

class _$_AddressDistrictType implements _AddressDistrictType {
  _$_AddressDistrictType();

  @override
  String toString() {
    return 'AddressType.district()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AddressDistrictType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() province,
    required TResult Function() district,
    required TResult Function() ward,
  }) {
    return district();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
  }) {
    return district?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
    required TResult orElse(),
  }) {
    if (district != null) {
      return district();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AddressProvinceType value) province,
    required TResult Function(_AddressDistrictType value) district,
    required TResult Function(_AddressWardType value) ward,
  }) {
    return district(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
  }) {
    return district?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
    required TResult orElse(),
  }) {
    if (district != null) {
      return district(this);
    }
    return orElse();
  }
}

abstract class _AddressDistrictType implements AddressType {
  factory _AddressDistrictType() = _$_AddressDistrictType;
}

/// @nodoc
abstract class _$$_AddressWardTypeCopyWith<$Res> {
  factory _$$_AddressWardTypeCopyWith(
          _$_AddressWardType value, $Res Function(_$_AddressWardType) then) =
      __$$_AddressWardTypeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AddressWardTypeCopyWithImpl<$Res>
    extends _$AddressTypeCopyWithImpl<$Res>
    implements _$$_AddressWardTypeCopyWith<$Res> {
  __$$_AddressWardTypeCopyWithImpl(
      _$_AddressWardType _value, $Res Function(_$_AddressWardType) _then)
      : super(_value, (v) => _then(v as _$_AddressWardType));

  @override
  _$_AddressWardType get _value => super._value as _$_AddressWardType;
}

/// @nodoc

class _$_AddressWardType implements _AddressWardType {
  _$_AddressWardType();

  @override
  String toString() {
    return 'AddressType.ward()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AddressWardType);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() province,
    required TResult Function() district,
    required TResult Function() ward,
  }) {
    return ward();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
  }) {
    return ward?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? province,
    TResult Function()? district,
    TResult Function()? ward,
    required TResult orElse(),
  }) {
    if (ward != null) {
      return ward();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AddressProvinceType value) province,
    required TResult Function(_AddressDistrictType value) district,
    required TResult Function(_AddressWardType value) ward,
  }) {
    return ward(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
  }) {
    return ward?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AddressProvinceType value)? province,
    TResult Function(_AddressDistrictType value)? district,
    TResult Function(_AddressWardType value)? ward,
    required TResult orElse(),
  }) {
    if (ward != null) {
      return ward(this);
    }
    return orElse();
  }
}

abstract class _AddressWardType implements AddressType {
  factory _AddressWardType() = _$_AddressWardType;
}
